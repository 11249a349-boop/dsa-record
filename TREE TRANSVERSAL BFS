Aim of Tree Traversal (BFS / Level Order)

To traverse a binary tree using Breadth-First Search (BFS) strategy, visiting all nodes level by level from top to bottom, and to demonstrate the use of a queue in tree traversal.

PROGRAM:
#include <stdio.h>
#include <stdlib.h>

// Node structure for binary tree
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Queue structure for BFS
struct Queue {
    struct Node* nodes[100];
    int front;
    int rear;
};

// Function to create a new binary tree node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Initialize queue
void initQueue(struct Queue* q) {
    q->front = 0;
    q->rear = -1;
}

// Enqueue
void enqueue(struct Queue* q, struct Node* node) {
    q->nodes[++(q->rear)] = node;
}

// Dequeue
struct Node* dequeue(struct Queue* q) {
    return q->nodes[(q->front)++];
}

// Check if queue is empty
int isEmpty(struct Queue* q) {
    return q->front > q->rear;
}

// BFS / Level Order Traversal
void levelOrder(struct Node* root) {
    if(root == NULL) return;

    struct Queue q;
    initQueue(&q);
    enqueue(&q, root);

    while(!isEmpty(&q)) {
        struct Node* current = dequeue(&q);
        printf("%d ", current->data);

        if(current->left != NULL) enqueue(&q, current->left);
        if(current->right != NULL) enqueue(&q, current->right);
    }
}

// Main function
int main() {
    // Creating a simple binary tree
    //        1
    //       / \
    //      2   3
    //     / \
    //    4   5
    struct Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);

    printf("Level Order (BFS) traversal: ");
    levelOrder(root);
    printf("\n");

    return 0;
}
